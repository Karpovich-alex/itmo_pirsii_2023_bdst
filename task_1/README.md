# Практическая работа № 1 Бинарное кодирование структурированных данных

1) Самостоятельно разобраться в форматах кодирования таких как Protobuf/AVRO
2) По аналогии с существующими форматами кодирования спроектировать собственный
формат кодирования структурированных данных для объектно ориентированного ЯП. То
есть, написать свой сериализатор, который преобразует объект в набор байт. Необходимо
обойти объект как граф без циклов, не используя уже существующие средства
сериализации
3) Сравнить размеры закодированных сообщений, скорость кодирования и декодирования
спроектированного и существующего средства.

# Решение
Было решено производить кодирование последовательно всех полей, отсортировав по id поля.
В реализации предусмотрен алгоритм, который позволяет использовать разные версии схем, отличающиеся по структуре.
Решение не позволяет оставлять поля пустыми. Наличие всех полей класса **обязательно**.

## Сериализация
Для сериализации использовалась следующая структура:

Структура файла:
- Название схемы (string)
- Версия (unsigned char)
- Сериализованные данные

| Name                   | Type    |
|------------------------|---------|
| Название схемы         | string  |
| Версия                 | int     |
| Сериализованные данные | various |

## Сериализованные данные
При сериализации использовалось следующее соответствие:

| Python type  |            Actual type            |     Size (bytes) |
|:------------:|:---------------------------------:|-----------------:|
|     int      |        unsigned long long         |                8 |
|    float     |              	double|                8 |
|    bool    |               Bool                |                1 |
|     string     |              char[]               |      1+len(word) |
|     dict     | unsigned char + type(element(s)) | 1+size(elements) |
|     list     |  unsigned char + type(element(s)  |  1+size(elements |

Соответствие типом может быть настроено при инициализации класса сериализации.

### Сериализация сложных объектов
Для сериализации объектов list и dict использовался алгоритм, схожий с сериализацией строк
- Список
  
  Сначала сериализуется количество элементов в списке, затем подряд идут сериализованные элементы списка
- Словарь

  Сначала сериализуется количество ключей в словаре, затем Подряд идут сериализованные ключи и значения словаря
### Сериализация сложных объектов (классы)
Для классов, которые являются атрибутами главного класса сохраняется сначала размер сериализованного класса в байтах (4), затем сериализация не отличается от обычной сериализации класса.

## Benchmark
number of iterations = 100_000

|            |serialization (ms) ||             deserialization (ms)              |                          |              |
|------------|---------|---------|----------------------|--------------------------|--------------|
| Name       | mean    | var     | mean                 | var                      | size (bytes) |
| ---------- |---------|---------|----------------------| ------------------------ |--------------|
| our_code   | 8.13168 | 0.57657 |  7.64034              | 0.09719                  | 73           |
| protobuf   | 9.68578 | 6.53558 | 34.51494             | 27.07078                 | 39           |
| avro       |  |  |              |                  |            |

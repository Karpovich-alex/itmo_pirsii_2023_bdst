# Практическая работа № 1 Бинарное кодирование структурированных данных

1) Самостоятельно разобраться в форматах кодирования таких как Protobuf/AVRO
2) По аналогии с существующими форматами кодирования спроектировать собственный
формат кодирования структурированных данных для объектно ориентированного ЯП. То
есть, написать свой сериализатор, который преобразует объект в набор байт. Необходимо
обойти объект как граф без циклов, не используя уже существующие средства
сериализации
3) Сравнить размеры закодированных сообщений, скорость кодирования и декодирования
спроектированного и существующего средства.

# Решение
Было решено производить кодирование последовательно всех полей, отсортировав по id поля.
В реализации предусмотрен алгоритм, который позволяет использовать разные версии схем, отличающиеся по структуре.
Решение не позволяет оставлять поля пустыми. Наличие всех полей класса **обязательно**.
## Схема
Пример схемы представлен в [файле](./schema.yml)
Структура:
```yaml
pet:
  version: 1
  kind:
    id: 1
    type: str
  age:
    id: 2
    type: float
  legs:
    id: 3
    type: int
  is_cool:
    id: 4
    type: bool
  weights:
    id: 6
    type: list
    element_type: int
  food:
    id: 7
    type: food
  add_data:
    id: 7
    type: dict
    key_type: int
    element_type:
      type: dict
      key_type: str
      element_type: int
```
Главные элементы схемы - названия классов. 
В классе есть зарезервированное поле: version
Эти поля (название и версия схемы) используются для сопоставления описания схемы и объекта класса.
В классе перечисляются поля, которые будут сериализованы
Для полей предусмотрены следующие поля:

| Name         | Type          | Description                                                                                            |
|--------------|---------------|--------------------------------------------------------------------------------------------------------|
| id           | int           | Уникальный номер поля. Не должен изменяться для одной версии схемы.                                    |
| type         | str or schema | Тип поля (python). Соответствие типов python и сериализации представлено ниже.                         |
| version      | int           | Версия схемы. Используется если type=<schema_name>.                                                    |
| element_type | str or nested | Используется для list и dict. Описывает тип вложенных элементов. Все элементы должны быть одного типа. |
| key_type     | str or nested | Используется только для dict. Описывает тип ключей для словаря. Все ключи одного типа.                 |

## Сериализация
Для сериализации использовалась следующая структура:

Структура файла:
- Название схемы
- Версия
- Сериализованные данные

| Name                   | Type    |
|------------------------|---------|
| Название схемы         | string  |
| Версия                 | int     |
| Сериализованные данные | various |


### Сериализованные данные
При сериализации использовалось следующее соответствие:

| Python type  |            Actual type            |     Size (bytes) |
|:------------:|:---------------------------------:|-----------------:|
|     int      |        unsigned long long         |                8 |
|    float     |              	double|                8 |
|    bool    |               Bool                |                1 |
|     string     |              char[]               |      1+len(word) |
|     dict     | unsigned char + type(element(s)) | 1+size(elements) |
|     list     |  unsigned char + type(element(s)  |  1+size(elements |

Соответствие типом может быть настроено при инициализации класса сериализации.

#### Сериализация сложных объектов
Для сериализации объектов list и dict использовался алгоритм, схожий с сериализацией строк
- Список
  
  Сначала сериализуется количество элементов в списке, затем подряд идут сериализованные элементы списка
- Словарь

  Сначала сериализуется количество ключей в словаре, затем Подряд идут сериализованные ключи и значения словаря
#### Сериализация сложных объектов (классы)
Для классов, которые являются атрибутами главного класса сохраняется сначала размер сериализованного класса в байтах (4), затем сериализация не отличается от обычной сериализации класса.

## Benchmark
number of iterations = 100_000

|            |serialization (ms) ||             deserialization (ms)              |                          |                |
|------------|---------|---------|----------------------|--------------------------|----------------|
| Name       | mean    | var     | mean                 | var                      | size (bytes)   |
| ---------- |---------|---------|----------------------| ------------------------ | -------------- |
| our_code | 7.81168     | 0.40426   | 7.32086              | 0.24900                | 164            |
| protobuf   | 9.68578 | 6.53558 | 34.51494             | 27.07078                 | 39             |
| avro       | 11601.28148 | 378.22856 | 38018.89886          | 705.65521        | 747            |

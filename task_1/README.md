# Практическая работа № 1 Бинарное кодирование структурированных данных

1) Самостоятельно разобраться в форматах кодирования таких как Protobuf/AVRO
2) По аналогии с существующими форматами кодирования спроектировать собственный
формат кодирования структурированных данных для объектно ориентированного ЯП. То
есть, написать свой сериализатор, который преобразует объект в набор байт. Необходимо
обойти объект как граф без циклов, не используя уже существующие средства
сериализации
3) Сравнить размеры закодированных сообщений, скорость кодирования и декодирования
спроектированного и существующего средства.

# Решение
Было решено производить кодирование последовательно всех полей, отсортировав по id поля.
В реализации предусмотрен алгоритм, который позволяет использовать разные версии схем, отличающиеся по структуре.
Решение не позволяет оставлять поля пустыми. Наличие всех полей класса **обязательно**.
## Схема
Пример схемы представлен в [файле](./schema.yml)
Структура:
```yaml
pet:
  version: 1
  kind:
    id: 1
    type: str
  age:
    id: 2
    type: float
  legs:
    id: 3
    type: int
  is_cool:
    id: 4
    type: bool
  weights:
    id: 6
    type: list
    element_type: int
  food:
    id: 7
    type: food
  add_data:
    id: 7
    type: dict
    key_type: int
    element_type:
      type: dict
      key_type: str
      element_type: int
```
Главные элементы схемы - названия классов. 
В классе есть зарезервированное поле: version
Эти поля (название и версия схемы) используются для сопоставления описания схемы и объекта класса.
В классе перечисляются поля, которые будут сериализованы
Для полей предусмотрены следующие поля:

| Name         | Type          | Description                                                                                            |
|--------------|---------------|--------------------------------------------------------------------------------------------------------|
| id           | int           | Уникальный номер поля. Не должен изменяться для одной версии схемы.                                    |
| type         | str or schema | Тип поля (python). Соответствие типов python и сериализации представлено ниже.                         |
| version      | int           | Версия схемы. Используется если type=<schema_name>.                                                    |
| element_type | str or nested | Используется для list и dict. Описывает тип вложенных элементов. Все элементы должны быть одного типа. |
| key_type     | str or nested | Используется только для dict. Описывает тип ключей для словаря. Все ключи одного типа.                 |

## Сериализация
Для сериализации использовалась следующая структура:

Структура файла:
- Название схемы
- Версия
- Сериализованные данные

| Name                   | Type    |
|------------------------|---------|
| Название схемы         | string  |
| Версия                 | int     |
| Сериализованные данные | various |


### Сериализованные данные
При сериализации использовалось следующее соответствие:

| Python type  |            Actual type            |     Size (bytes) |
|:------------:|:---------------------------------:|-----------------:|
|     int      |        unsigned long long         |                8 |
|    float     |              	double|                8 |
|    bool    |               Bool                |                1 |
|     string     |              char[]               |      1+len(word) |
|     dict     | unsigned char + type(element(s)) | 1+size(elements) |
|     list     |  unsigned char + type(element(s)  |  1+size(elements |

Соответствие типом может быть настроено при инициализации класса сериализации.

#### Сериализация сложных объектов
Для сериализации объектов list и dict использовался алгоритм, схожий с сериализацией строк
- Список
  
  Сначала сериализуется количество элементов в списке, затем подряд идут сериализованные элементы списка
- Словарь

  Сначала сериализуется количество ключей в словаре, затем Подряд идут сериализованные ключи и значения словаря
#### Сериализация сложных объектов (классы)
Для классов, которые являются атрибутами главного класса сохраняется сначала размер сериализованного класса в байтах (4), затем сериализация не отличается от обычной сериализации класса.

## Benchmark
number of iterations = 100_000

perf_counter_ns*1e+6

|            |serialization (ms) |           |             deserialization (ms)              |           |                |
|------------|---------|-----------|----------------------|-----------|----------------|
| Name       | mean    | std       | mean                 | std       | size (bytes)   |
| our_code | 0.03124     | 0.04420   | 0.03462              | 0.010975   | 164            |
| protobuf   | 0.00798 | 0.00097   | 0.00099             | 0.02920  | 39             |
| avro       | 0.34592 | 0.37370 | 0.36354          | 0.10084 | 747            |


perf_counter_ns*1e+6
serialization = define object + serialize
deserialization = deserialize + construct class\json-str

|            |serialization (ms) |           |             deserialization (ms)              |           |                |
|------------|---------|-----------|----------------------|-----------|----------------|
| Name       | mean    | std       | mean                 | std       | size (bytes)   |
| our_code | 0.03104     | 0.00686   | 0.03513              | 0.01042   | 164            |
| protobuf   | 0.00108 | 0.00097   | 0.08516             | 0.02492  | 39             |
| avro       | 0.33317 | 0.07996 | 0.35643          | 0.05904 | 747            |
